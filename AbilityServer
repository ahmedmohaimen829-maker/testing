-- Optimized Hold Animation ServerScript
-- Place this in ServerScriptService
--
-- OPTIMIZED: Single hitbox per ability, reduced frame checks, instant knockback

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

-- Wait for RemoteEvent
local reFolder = ReplicatedStorage:WaitForChild("RE")
local slashAbilityEvent = reFolder:FindFirstChild("SlashAbilityEvent")
if not slashAbilityEvent then
	slashAbilityEvent = Instance.new("RemoteEvent")
	slashAbilityEvent.Name = "SlashAbilityEvent"
	slashAbilityEvent.Parent = reFolder
end

-- Hitbox Configuration
local HITBOX_SIZE = Vector3.new(6, 6, 6)
local HITBOX_FORWARD_OFFSET = 3.2

-- Damage Configuration
local DAMAGE_PER_HIT = 5

-- Pushback Configuration
local PUSHBACK_FORCE = 35
local PUSHBACK_DURATION = 0.15

-- Highlight Configuration
local HIGHLIGHT_FILL_COLOR = Color3.fromRGB(255, 0, 0)
local HIGHLIGHT_OUTLINE_COLOR = Color3.fromRGB(200, 0, 0)
local HIGHLIGHT_FILL_TRANSPARENCY = 0.3
local HIGHLIGHT_FLICKER_TIME = 0.05

-- Knockback & Ragdoll Configuration (for Final hit only)
local KNOCKBACK_UP_VELOCITY = 100
local KNOCKBACK_BACK_VELOCITY = 120
local RAGDOLL_DURATION = 2

-- OPTIMIZATION: Frame skip for hitbox checks (check every N frames instead of every frame)
local HITBOX_CHECK_INTERVAL = 2 -- Check every 2 frames

-- Track active abilities
local activeAbilities = {}

-- Track ragdolled characters
local ragdolledCharacters = {}

-- Function to get base walk speed (prevents stacking)
local function getBaseWalkSpeed(humanoid)
	if not humanoid:GetAttribute("BaseWalkSpeed") then
		humanoid:SetAttribute("BaseWalkSpeed", humanoid.WalkSpeed)
	end
	return humanoid:GetAttribute("BaseWalkSpeed")
end

-- Function to lock target player's movement
local function lockTargetMovement(targetCharacter, targetHumanoid)
	if not targetCharacter or not targetCharacter.Parent then return end
	if not targetHumanoid then return end

	local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
	if not targetRootPart then return end

	local baseWalkSpeed = getBaseWalkSpeed(targetHumanoid)
	if not targetHumanoid:GetAttribute("BaseJumpPower") then
		targetHumanoid:SetAttribute("BaseJumpPower", targetHumanoid.JumpPower)
	end
	local baseJumpPower = targetHumanoid:GetAttribute("BaseJumpPower")

	targetHumanoid.WalkSpeed = 0
	targetHumanoid.JumpPower = 0

	return {baseWalkSpeed, baseJumpPower}
end

-- Function to unlock target player's movement
local function unlockTargetMovement(targetCharacter, lockData)
	if not targetCharacter or not targetCharacter.Parent then return end
	if not lockData then return end

	local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
	if targetHumanoid then
		targetHumanoid.WalkSpeed = lockData[1]
		targetHumanoid.JumpPower = lockData[2]
	end
end

-- OPTIMIZATION: Simplified pushback using direct velocity
local function applyPushback(targetCharacter, abilityOwnerRootPart)
	if not targetCharacter or not targetCharacter.Parent then return end
	if not abilityOwnerRootPart or not abilityOwnerRootPart.Parent then return end

	local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
	if not targetRootPart then return end

	local direction = (targetRootPart.Position - abilityOwnerRootPart.Position)
	local distance = direction.Magnitude
	if distance == 0 then return end

	direction = (direction / distance) * Vector3.new(1, 0, 1)

	local pushbackVelocity = direction * PUSHBACK_FORCE
	local currentY = targetRootPart.AssemblyLinearVelocity.Y

	-- Apply instant pushback
	targetRootPart.AssemblyLinearVelocity = Vector3.new(
		pushbackVelocity.X,
		currentY,
		pushbackVelocity.Z
	)

	-- OPTIMIZATION: Simple decay without continuous loop
	task.delay(PUSHBACK_DURATION, function()
		if targetRootPart and targetRootPart.Parent then
			local finalY = targetRootPart.AssemblyLinearVelocity.Y
			targetRootPart.AssemblyLinearVelocity = Vector3.new(0, finalY, 0)
		end
	end)
end

-- ============================================
-- RAGDOLL SYSTEM (for Final hit)
-- ============================================

local function getMotor6Ds(character)
	local motors = {}
	for _, descendant in ipairs(character:GetDescendants()) do
		if descendant:IsA("Motor6D") then
			table.insert(motors, descendant)
		end
	end
	return motors
end

local function createRagdollConstraint(motor)
	local socket = Instance.new("BallSocketConstraint")
	socket.Name = "RagdollSocket_" .. motor.Name
	socket.LimitsEnabled = true
	socket.TwistLimitsEnabled = true
	socket.UpperAngle = 50
	socket.TwistLowerAngle = -50
	socket.TwistUpperAngle = 50

	local att0 = Instance.new("Attachment")
	att0.Name = "RagdollAtt0"
	att0.CFrame = motor.C0
	att0.Parent = motor.Part0

	local att1 = Instance.new("Attachment")
	att1.Name = "RagdollAtt1"
	att1.CFrame = motor.C1
	att1.Parent = motor.Part1

	socket.Attachment0 = att0
	socket.Attachment1 = att1
	socket.Parent = motor.Part0

	return socket, att0, att1
end

local function enableRagdoll(character)
	if ragdolledCharacters[character] then return false end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end

	local ragdollData = {
		motors = {},
		sockets = {},
		attachments = {},
		constraints = {}
	}

	humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, false)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics, false)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
	humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	humanoid.PlatformStand = true

	local motors = getMotor6Ds(character)

	for _, motor in ipairs(motors) do
		if motor.Name ~= "RootJoint" and motor.Name ~= "Root" then
			table.insert(ragdollData.motors, {
				motor = motor,
				enabled = motor.Enabled
			})

			local socket, att0, att1 = createRagdollConstraint(motor)
			table.insert(ragdollData.sockets, socket)
			table.insert(ragdollData.attachments, att0)
			table.insert(ragdollData.attachments, att1)

			motor.Enabled = false
		end
	end

	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = true
		end
	end

	ragdolledCharacters[character] = ragdollData
	return true
end

local function disableRagdoll(character)
	local ragdollData = ragdolledCharacters[character]
	if not ragdollData then return end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local rootPart = character:FindFirstChild("HumanoidRootPart")

	-- Cleanup constraints
	for _, constraint in ipairs(ragdollData.constraints) do
		if constraint and constraint.Parent then
			constraint:Destroy()
		end
	end

	-- Stop all movement
	if rootPart then
		rootPart.AssemblyLinearVelocity = Vector3.zero
		rootPart.AssemblyAngularVelocity = Vector3.zero
	end

	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") then
			part.AssemblyLinearVelocity = Vector3.zero
			part.AssemblyAngularVelocity = Vector3.zero
		end
	end

	-- Disable collision
	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
			part.CanCollide = false
		end
	end

	-- Position character upright
	if rootPart then
		local currentPos = rootPart.Position
		local raycastParams = RaycastParams.new()
		raycastParams.FilterDescendantsInstances = {character}
		raycastParams.FilterType = Enum.RaycastFilterType.Exclude

		local rayResult = workspace:Raycast(currentPos, Vector3.new(0, -10, 0), raycastParams)
		local groundY = rayResult and rayResult.Position.Y or (currentPos.Y - 3)
		local hipHeight = humanoid and humanoid.HipHeight or 2
		local newY = groundY + hipHeight + 1

		rootPart.CFrame = CFrame.new(currentPos.X, newY, currentPos.Z)
		rootPart.AssemblyLinearVelocity = Vector3.zero
		rootPart.AssemblyAngularVelocity = Vector3.zero
	end

	-- Cleanup sockets and attachments
	for _, socket in ipairs(ragdollData.sockets) do
		if socket and socket.Parent then
			socket:Destroy()
		end
	end

	for _, att in ipairs(ragdollData.attachments) do
		if att and att.Parent then
			att:Destroy()
		end
	end

	-- Re-enable motors
	for _, motorData in ipairs(ragdollData.motors) do
		if motorData.motor and motorData.motor.Parent then
			motorData.motor.Enabled = true
		end
	end

	-- Re-enable humanoid
	if humanoid then
		humanoid.PlatformStand = false
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, true)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics, true)
		humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
	end

	ragdolledCharacters[character] = nil
end

-- OPTIMIZATION: Instant knockback application for Final hit
local function applyFinalKnockback(character, hitPosition, ragdollData)
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return end

	-- Calculate direction
	local direction = (rootPart.Position - hitPosition)
	direction = Vector3.new(direction.X, 0, direction.Z)

	if direction.Magnitude > 0.1 then
		direction = direction.Unit
	else
		local angle = math.random() * math.pi * 2
		direction = Vector3.new(math.cos(angle), 0, math.sin(angle))
	end

	-- OPTIMIZATION: Apply velocity directly for instant feedback
	local knockbackVelocity = Vector3.new(
		direction.X * KNOCKBACK_BACK_VELOCITY,
		KNOCKBACK_UP_VELOCITY,
		direction.Z * KNOCKBACK_BACK_VELOCITY
	)

	-- Apply directly to AssemblyLinearVelocity for INSTANT effect
	rootPart.AssemblyLinearVelocity = knockbackVelocity

	-- Add angular velocity for tumbling
	rootPart.AssemblyAngularVelocity = Vector3.new(
		math.random(-8, 8),
		math.random(-4, 4),
		math.random(-8, 8)
	)

	-- OPTIMIZATION: Use LinearVelocity constraint only for sustained force (optional smoothing)
	local attachment = Instance.new("Attachment")
	attachment.Name = "KnockbackAttachment"
	attachment.Parent = rootPart

	local linearVelocity = Instance.new("LinearVelocity")
	linearVelocity.Name = "KnockbackVelocity"
	linearVelocity.Attachment0 = attachment
	linearVelocity.MaxForce = 50000 -- Reduced from math.huge for smoother feel
	linearVelocity.VectorVelocity = knockbackVelocity * 0.5 -- Reduced sustained force
	linearVelocity.RelativeTo = Enum.ActuatorRelativeTo.World
	linearVelocity.Parent = rootPart

	if ragdollData then
		table.insert(ragdollData.constraints, linearVelocity)
		table.insert(ragdollData.attachments, attachment)
	end

	-- Quick decay
	task.delay(0.2, function()
		if linearVelocity and linearVelocity.Parent then
			linearVelocity.MaxForce = 0
		end
	end)
end

local function knockbackAndRagdoll(character, hitPosition)
	if ragdolledCharacters[character] then return end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Health <= 0 then return end

	local success = enableRagdoll(character)
	if not success then return end

	local ragdollData = ragdolledCharacters[character]
	applyFinalKnockback(character, hitPosition, ragdollData)

	task.delay(RAGDOLL_DURATION, function()
		if character and character.Parent then
			disableRagdoll(character)
		end
	end)
end

-- OPTIMIZATION: Simplified highlight flicker
local function flickerHighlightOnHit(character)
	if not character or not character.Parent then return end

	local highlight = Instance.new("Highlight")
	highlight.Name = "SlashHitFlicker"
	highlight.FillColor = HIGHLIGHT_FILL_COLOR
	highlight.OutlineColor = HIGHLIGHT_OUTLINE_COLOR
	highlight.FillTransparency = HIGHLIGHT_FILL_TRANSPARENCY
	highlight.OutlineTransparency = 0
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Enabled = true
	highlight.Parent = character

	-- Simple tween sequence
	local fadeOut = TweenService:Create(
		highlight,
		TweenInfo.new(HIGHLIGHT_FLICKER_TIME * 1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{FillTransparency = 1, OutlineTransparency = 1}
	)

	task.delay(HIGHLIGHT_FLICKER_TIME, function()
		if highlight and highlight.Parent then
			fadeOut:Play()
			fadeOut.Completed:Connect(function()
				if highlight and highlight.Parent then
					highlight:Destroy()
				end
			end)
		end
	end)
end

-- OPTIMIZATION: Process a single hit event (called per VFX action)
local function processHit(player, character, humanoidRootPart, vfxType)
	if not character or not character.Parent then return end
	if not humanoidRootPart or not humanoidRootPart.Parent then return end

	local abilityData = activeAbilities[player]
	if not abilityData then return end

	-- OPTIMIZATION: Single spatial query per action
	local overlapParams = OverlapParams.new()
	overlapParams.FilterType = Enum.RaycastFilterType.Exclude
	overlapParams.FilterDescendantsInstances = {character}

	local lookVector = humanoidRootPart.CFrame.LookVector
	local hitboxPosition = humanoidRootPart.Position + (lookVector * HITBOX_FORWARD_OFFSET)
	local hitboxCFrame = CFrame.new(hitboxPosition, hitboxPosition + lookVector)

	local partsInBox = workspace:GetPartBoundsInBox(hitboxCFrame, HITBOX_SIZE, overlapParams)

	-- Track which characters we've already processed this frame
	local processedCharacters = {}

	for _, part in ipairs(partsInBox) do
		local targetCharacter = part.Parent

		-- Skip if already processed this character
		if processedCharacters[targetCharacter] then continue end

		if targetCharacter and targetCharacter:FindFirstChild("Humanoid") then
			local targetPlayer = Players:GetPlayerFromCharacter(targetCharacter)

			if targetPlayer and targetPlayer ~= player then
				local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")

				if targetHumanoid and targetHumanoid.Health > 0 then
					processedCharacters[targetCharacter] = true

					-- Check if this is a new hit for this VFX type
					local hitKey = targetPlayer.UserId .. "_" .. vfxType
					if not abilityData.hitsByType[hitKey] then
						abilityData.hitsByType[hitKey] = true

						-- Apply damage
						targetHumanoid.Health = math.max(0, targetHumanoid.Health - DAMAGE_PER_HIT)

						-- Apply effects based on type
						if vfxType == "Final" then
							-- Unlock if previously locked
							if abilityData.hitPlayers[targetPlayer] and abilityData.hitPlayers[targetPlayer].lockData then
								unlockTargetMovement(targetCharacter, abilityData.hitPlayers[targetPlayer].lockData)
							end

							-- INSTANT knockback and ragdoll
							knockbackAndRagdoll(targetCharacter, humanoidRootPart.Position)

							abilityData.hitPlayers[targetPlayer] = {
								character = targetCharacter,
								humanoid = targetHumanoid,
								lockData = nil
							}
						else
							-- Normal hit: lock on first hit, then pushback
							if not abilityData.hitPlayers[targetPlayer] then
								local lockData = lockTargetMovement(targetCharacter, targetHumanoid)
								abilityData.hitPlayers[targetPlayer] = {
									character = targetCharacter,
									humanoid = targetHumanoid,
									lockData = lockData
								}
							end

							applyPushback(targetCharacter, humanoidRootPart)
						end

						-- Visual feedback
						flickerHighlightOnHit(targetCharacter)
					end
				end
			end
		end
	end
end

-- CONSOLIDATED: Single event handler for all actions
slashAbilityEvent.OnServerEvent:Connect(function(player, action, character)
	if not player or not character or not character.Parent then return end

	-- Verify character ownership
	if Players:GetPlayerFromCharacter(character) ~= player then return end

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")

	-- Handle ability start
	if action == "AbilityStart" then
		activeAbilities[player] = {
			character = character,
			startTime = tick(),
			hitPlayers = {},
			hitsByType = {} -- OPTIMIZATION: Track hits by type to prevent duplicate processing
		}
		return
	end

	-- Handle ability end
	if action == "AbilityEnd" then
		local abilityData = activeAbilities[player]
		if abilityData then
			for targetPlayer, data in pairs(abilityData.hitPlayers) do
				if not ragdolledCharacters[data.character] then
					unlockTargetMovement(data.character, data.lockData)
				end
			end
			activeAbilities[player] = nil
		end
		return
	end

	-- Handle VFX events (Stab, Slash1, Slash3, Slash4, Final)
	if humanoidRootPart then
		-- OPTIMIZATION: Process hit immediately (no continuous hitbox)
		processHit(player, character, humanoidRootPart, action)
	end

	-- Replicate to other clients
	for _, otherPlayer in ipairs(Players:GetPlayers()) do
		if otherPlayer ~= player then
			slashAbilityEvent:FireClient(otherPlayer, action, character)
		end
	end
end)

-- Cleanup on player leaving
Players.PlayerRemoving:Connect(function(player)
	if activeAbilities[player] then
		local abilityData = activeAbilities[player]
		for targetPlayer, data in pairs(abilityData.hitPlayers) do
			if not ragdolledCharacters[data.character] then
				unlockTargetMovement(data.character, data.lockData)
			end
		end
		activeAbilities[player] = nil
	end

	-- Also cleanup ragdoll for leaving player
	local character = player.Character
	if character and ragdolledCharacters[character] then
		disableRagdoll(character)
	end
end)

-- Cleanup ragdoll on character removal
local function setupCharacterCleanup(player)
	player.CharacterRemoving:Connect(function(character)
		if ragdolledCharacters[character] then
			disableRagdoll(character)
		end
	end)
end

for _, player in ipairs(Players:GetPlayers()) do
	setupCharacterCleanup(player)
end

Players.PlayerAdded:Connect(function(player)
	setupCharacterCleanup(player)
end)
