-- Hold Animation ServerScript
-- Place this in ServerScriptService
--
-- This script handles server-side replication of VFX and audio, plus hitbox/damage system

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")

-- Wait for RemoteEvent
local reFolder = ReplicatedStorage:WaitForChild("RE")
local slashAbilityEvent = reFolder:FindFirstChild("SlashAbilityEvent")
if not slashAbilityEvent then
	slashAbilityEvent = Instance.new("RemoteEvent")
	slashAbilityEvent.Name = "SlashAbilityEvent"
	slashAbilityEvent.Parent = reFolder
end

-- Hitbox Configuration
local HITBOX_SIZE = Vector3.new(6, 6, 6)
local HITBOX_FORWARD_OFFSET = 3.2
local HITBOX_DURATION = 0.5
local HITBOX_TRANSPARENCY = 0.5

-- Damage Configuration
local DAMAGE_PER_HIT = 5

-- Pushback Configuration
local PUSHBACK_FORCE = 35 -- INCREASED from 10 to 50
local PUSHBACK_DURATION = 0.15 -- DECREASED from 0.3 to 0.15 for snappier feel

-- Highlight Configuration
local HIGHLIGHT_FILL_COLOR = Color3.fromRGB(255, 0, 0)
local HIGHLIGHT_OUTLINE_COLOR = Color3.fromRGB(200, 0, 0)
local HIGHLIGHT_FILL_TRANSPARENCY = 0.3
local HIGHLIGHT_FLICKER_TIME = 0.05 -- CHANGED from 0.1 to 0.05 (quicker flicker)

-- Knockback & Ragdoll Configuration (for Final hit only)
local KNOCKBACK_UP_VELOCITY = 100 -- Smooth upward explosion
local KNOCKBACK_BACK_VELOCITY = 120 -- Smooth backward push
local RAGDOLL_DURATION = 2 -- How long ragdoll lasts (seconds)

-- Track active abilities and hit players
local activeAbilities = {}

-- Track ragdolled characters
local ragdolledCharacters = {}

-- Function to get base walk speed (prevents stacking)
local function getBaseWalkSpeed(humanoid)
	if not humanoid:GetAttribute("BaseWalkSpeed") then
		humanoid:SetAttribute("BaseWalkSpeed", humanoid.WalkSpeed)
	end
	return humanoid:GetAttribute("BaseWalkSpeed")
end

-- Function to lock target player's movement
local function lockTargetMovement(targetCharacter, targetHumanoid)
	if not targetCharacter or not targetCharacter.Parent then return end
	if not targetHumanoid then return end

	local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
	if not targetRootPart then return end

	-- Store original walk speed and jump power
	local baseWalkSpeed = getBaseWalkSpeed(targetHumanoid)
	if not targetHumanoid:GetAttribute("BaseJumpPower") then
		targetHumanoid:SetAttribute("BaseJumpPower", targetHumanoid.JumpPower)
	end
	local baseJumpPower = targetHumanoid:GetAttribute("BaseJumpPower")

	-- Lock movement
	targetHumanoid.WalkSpeed = 0
	targetHumanoid.JumpPower = 0

	-- REMOVED AlignPosition - this was preventing pushback from working
	-- Movement is now locked only via WalkSpeed = 0, allowing pushback to work

	return {baseWalkSpeed, baseJumpPower}
end

-- Function to unlock target player's movement
local function unlockTargetMovement(targetCharacter, lockData)
	if not targetCharacter or not targetCharacter.Parent then return end
	if not lockData then return end

	local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
	if targetHumanoid then
		targetHumanoid.WalkSpeed = lockData[1] -- Restore base walk speed
		targetHumanoid.JumpPower = lockData[2] -- Restore base jump power
	end
end

-- Function to apply pushback to target character
local function applyPushback(targetCharacter, abilityOwnerRootPart)
	if not targetCharacter or not targetCharacter.Parent then return end
	if not abilityOwnerRootPart or not abilityOwnerRootPart.Parent then return end

	local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
	if not targetRootPart then return end

	-- Calculate direction from ability owner to target (push away)
	local direction = (targetRootPart.Position - abilityOwnerRootPart.Position)
	local distance = direction.Magnitude
	if distance == 0 then return end

	direction = (direction / distance) * Vector3.new(1, 0, 1) -- Normalize and flatten (no Y component)

	-- CHANGED: Use AssemblyLinearVelocity for instant pushback (more reliable than BodyVelocity)
	local currentVelocity = targetRootPart.AssemblyLinearVelocity
	local pushbackVelocity = direction * PUSHBACK_FORCE

	-- Apply pushback instantly
	targetRootPart.AssemblyLinearVelocity = Vector3.new(
		pushbackVelocity.X,
		currentVelocity.Y, -- Keep Y velocity (don't affect jumping/falling)
		pushbackVelocity.Z
	)

	-- Gradually decay the pushback
	task.spawn(function()
		local startTime = tick()
		local startVelocity = targetRootPart.AssemblyLinearVelocity

		while tick() - startTime < PUSHBACK_DURATION do
			if not targetRootPart or not targetRootPart.Parent then break end

			local progress = (tick() - startTime) / PUSHBACK_DURATION
			local decayFactor = 1 - progress

			local currentVel = targetRootPart.AssemblyLinearVelocity
			targetRootPart.AssemblyLinearVelocity = Vector3.new(
				pushbackVelocity.X * decayFactor,
				currentVel.Y, -- Preserve Y velocity
				pushbackVelocity.Z * decayFactor
			)

			task.wait()
		end

		-- Stop horizontal movement
		if targetRootPart and targetRootPart.Parent then
			local finalVel = targetRootPart.AssemblyLinearVelocity
			targetRootPart.AssemblyLinearVelocity = Vector3.new(0, finalVel.Y, 0)
		end
	end)
end

-- ============================================
-- RAGDOLL SYSTEM (for Final hit)
-- ============================================

local function getMotor6Ds(character)
	local motors = {}
	for _, descendant in ipairs(character:GetDescendants()) do
		if descendant:IsA("Motor6D") then
			table.insert(motors, descendant)
		end
	end
	return motors
end

local function createRagdollConstraint(motor)
	local socket = Instance.new("BallSocketConstraint")
	socket.Name = "RagdollSocket_" .. motor.Name
	socket.LimitsEnabled = true
	socket.TwistLimitsEnabled = true
	socket.UpperAngle = 50
	socket.TwistLowerAngle = -50
	socket.TwistUpperAngle = 50

	local att0 = Instance.new("Attachment")
	att0.Name = "RagdollAtt0"
	att0.CFrame = motor.C0
	att0.Parent = motor.Part0

	local att1 = Instance.new("Attachment")
	att1.Name = "RagdollAtt1"
	att1.CFrame = motor.C1
	att1.Parent = motor.Part1

	socket.Attachment0 = att0
	socket.Attachment1 = att1
	socket.Parent = motor.Part0

	return socket, att0, att1
end

local function enableRagdoll(character)
	if ragdolledCharacters[character] then return false end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end

	local ragdollData = {
		motors = {},
		sockets = {},
		attachments = {},
		constraints = {}
	}

	-- Disable humanoid states
	humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, false)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics, false)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
	humanoid:ChangeState(Enum.HumanoidStateType.Physics)

	-- Set PlatformStand to prevent character from trying to stand
	humanoid.PlatformStand = true

	-- Process motors
	local motors = getMotor6Ds(character)

	for _, motor in ipairs(motors) do
		if motor.Name ~= "RootJoint" and motor.Name ~= "Root" then
			table.insert(ragdollData.motors, {
				motor = motor,
				enabled = motor.Enabled
			})

			local socket, att0, att1 = createRagdollConstraint(motor)
			table.insert(ragdollData.sockets, socket)
			table.insert(ragdollData.attachments, att0)
			table.insert(ragdollData.attachments, att1)

			motor.Enabled = false
		end
	end

	-- Enable collision on parts for physics
	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = true
		end
	end

	ragdolledCharacters[character] = ragdollData
	return true
end

local function disableRagdoll(character)
	local ragdollData = ragdolledCharacters[character]
	if not ragdollData then return end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local rootPart = character:FindFirstChild("HumanoidRootPart")

	-- Step 1: Clean up all constraints first
	for _, constraint in ipairs(ragdollData.constraints) do
		if constraint and constraint.Parent then
			constraint:Destroy()
		end
	end

	-- Step 2: Stop all movement immediately
	if rootPart then
		rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
		rootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
	end

	-- Stop velocity on all parts
	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") then
			part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
			part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
		end
	end

	-- Step 3: Disable collision on all parts BEFORE re-enabling motors
	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
			part.CanCollide = false
		end
	end

	-- Step 4: Position character upright before re-enabling motors
	if rootPart then
		-- Get current position but make character upright
		local currentPos = rootPart.Position

		-- Raycast down to find ground
		local raycastParams = RaycastParams.new()
		raycastParams.FilterDescendantsInstances = {character}
		raycastParams.FilterType = Enum.RaycastFilterType.Exclude

		local rayResult = workspace:Raycast(currentPos, Vector3.new(0, -10, 0), raycastParams)
		local groundY = rayResult and rayResult.Position.Y or (currentPos.Y - 3)

		-- Position character slightly above ground, upright
		local hipHeight = humanoid and humanoid.HipHeight or 2
		local newY = groundY + hipHeight + 1

		-- Set upright position (keep X and Z, fix Y and rotation)
		rootPart.CFrame = CFrame.new(currentPos.X, newY, currentPos.Z)

		-- Zero out velocity again after repositioning
		rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
		rootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
	end

	-- Step 5: Clean up ragdoll sockets
	for _, socket in ipairs(ragdollData.sockets) do
		if socket and socket.Parent then
			socket:Destroy()
		end
	end

	-- Clean up attachments
	for _, att in ipairs(ragdollData.attachments) do
		if att and att.Parent then
			att:Destroy()
		end
	end

	-- Step 6: Re-enable motors
	for _, motorData in ipairs(ragdollData.motors) do
		if motorData.motor and motorData.motor.Parent then
			motorData.motor.Enabled = true
		end
	end

	-- Step 7: Re-enable humanoid control
	if humanoid then
		humanoid.PlatformStand = false
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, true)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics, true)
		humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
	end

	ragdolledCharacters[character] = nil
end

-- Apply smooth knockback using LinearVelocity constraint (for Final hit)
local function applyFinalKnockback(character, hitPosition, ragdollData)
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return end

	-- Calculate direction away from hit (horizontal only)
	local direction = (rootPart.Position - hitPosition)
	direction = Vector3.new(direction.X, 0, direction.Z)

	if direction.Magnitude > 0.1 then
		direction = direction.Unit
	else
		-- If too close, push in a random direction
		local angle = math.random() * math.pi * 2
		direction = Vector3.new(math.cos(angle), 0, math.sin(angle))
	end

	-- Create knockback velocity (up and back)
	local knockbackVelocity = Vector3.new(
		direction.X * KNOCKBACK_BACK_VELOCITY,
		KNOCKBACK_UP_VELOCITY,
		direction.Z * KNOCKBACK_BACK_VELOCITY
	)

	-- Create attachment for LinearVelocity
	local attachment = Instance.new("Attachment")
	attachment.Name = "KnockbackAttachment"
	attachment.Parent = rootPart

	-- Use LinearVelocity for smooth, consistent knockback
	local linearVelocity = Instance.new("LinearVelocity")
	linearVelocity.Name = "KnockbackVelocity"
	linearVelocity.Attachment0 = attachment
	linearVelocity.MaxForce = math.huge -- Ensure it applies fully
	linearVelocity.VectorVelocity = knockbackVelocity
	linearVelocity.RelativeTo = Enum.ActuatorRelativeTo.World
	linearVelocity.Parent = rootPart

	-- Store for cleanup
	if ragdollData then
		table.insert(ragdollData.constraints, linearVelocity)
		table.insert(ragdollData.attachments, attachment)
	end

	-- Add some angular velocity for tumbling effect
	local angularVelocity = Instance.new("AngularVelocity")
	angularVelocity.Name = "KnockbackSpin"
	angularVelocity.Attachment0 = attachment
	angularVelocity.MaxTorque = math.huge
	angularVelocity.AngularVelocity = Vector3.new(
		math.random(-8, 8),
		math.random(-4, 4),
		math.random(-8, 8)
	)
	angularVelocity.RelativeTo = Enum.ActuatorRelativeTo.World
	angularVelocity.Parent = rootPart

	if ragdollData then
		table.insert(ragdollData.constraints, angularVelocity)
	end

	-- Smoothly reduce the knockback force over time
	task.spawn(function()
		local duration = 0.3 -- Knockback applies for 0.3 seconds
		local startTime = tick()
		local startVelocity = knockbackVelocity

		while tick() - startTime < duration do
			local alpha = (tick() - startTime) / duration
			local easedAlpha = 1 - math.pow(1 - alpha, 2) -- Ease out

			if linearVelocity and linearVelocity.Parent then
				-- Gradually reduce velocity, but keep some upward initially
				local currentVelocity = startVelocity * (1 - easedAlpha)
				linearVelocity.VectorVelocity = currentVelocity
			else
				break
			end

			task.wait()
		end

		-- Remove the linear velocity constraint (let physics take over)
		if linearVelocity and linearVelocity.Parent then
			linearVelocity.MaxForce = 0
		end

		-- Remove angular velocity after a bit
		task.delay(0.2, function()
			if angularVelocity and angularVelocity.Parent then
				angularVelocity.MaxTorque = 0
			end
		end)
	end)
end

local function knockbackAndRagdoll(character, hitPosition)
	if ragdolledCharacters[character] then return end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Health <= 0 then return end

	-- Enable ragdoll first
	local success = enableRagdoll(character)
	if not success then return end

	-- Apply knockback (pass ragdollData for cleanup tracking)
	local ragdollData = ragdolledCharacters[character]
	applyFinalKnockback(character, hitPosition, ragdollData)

	-- Schedule recovery
	task.delay(RAGDOLL_DURATION, function()
		if character and character.Parent then
			disableRagdoll(character)
		end
	end)
end

-- Function to create temporary red highlight flicker on hit
local function flickerHighlightOnHit(character)
	if not character or not character.Parent then return end

	-- Create temporary highlight for flicker
	local highlight = Instance.new("Highlight")
	highlight.Name = "SlashHitFlicker"
	highlight.FillColor = HIGHLIGHT_FILL_COLOR
	highlight.OutlineColor = HIGHLIGHT_OUTLINE_COLOR
	highlight.FillTransparency = HIGHLIGHT_FILL_TRANSPARENCY
	highlight.OutlineTransparency = 0
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Enabled = true
	highlight.Parent = character

	-- Flicker to bright red, then fade out and remove
	local darkRed = Color3.fromRGB(200, 0, 0)

	-- Quick flicker in (to bright red)
	local flickerIn = TweenService:Create(
		highlight,
		TweenInfo.new(HIGHLIGHT_FLICKER_TIME / 2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{
			FillColor = Color3.fromRGB(255, 50, 50), -- Bright red
			OutlineColor = Color3.fromRGB(255, 0, 0)
		}
	)

	-- Fade out and remove
	local fadeOut = TweenService:Create(
		highlight,
		TweenInfo.new(HIGHLIGHT_FLICKER_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
		{
			FillTransparency = 1,
			OutlineTransparency = 1
		}
	)

	flickerIn:Play()
	flickerIn.Completed:Connect(function()
		if highlight and highlight.Parent then
			fadeOut:Play()
			fadeOut.Completed:Connect(function()
				if highlight and highlight.Parent then
					highlight:Destroy()
				end
			end)
		end
	end)
end

-- Function to create and process hitbox
local function createHitbox(abilityOwner, character, humanoidRootPart, vfxType)
	if not character or not character.Parent then return end
	if not humanoidRootPart or not humanoidRootPart.Parent then return end

	-- Get or create ability data
	if not activeAbilities[abilityOwner] then
		activeAbilities[abilityOwner] = {
			character = character,
			startTime = tick(),
			hitPlayers = {}
		}
	end

	local abilityData = activeAbilities[abilityOwner]

	-- Create hitbox part
	local hitbox = Instance.new("Part")
	hitbox.Name = "SlashAbilityHitbox"
	hitbox.Size = HITBOX_SIZE
	hitbox.Anchored = true
	hitbox.CanCollide = false
	hitbox.Transparency = HITBOX_TRANSPARENCY
	hitbox.Color = Color3.fromRGB(255, 0, 0)
	hitbox.Material = Enum.Material.ForceField
	hitbox.CanTouch = false
	hitbox.Parent = workspace

	-- Track which players have been hit by THIS specific hitbox instance
	local hitboxHitPlayers = {}

	-- Process hitbox
	local connection
	connection = RunService.Heartbeat:Connect(function()
		if not character or not character.Parent then
			connection:Disconnect()
			hitbox:Destroy()
			return
		end

		if not humanoidRootPart or not humanoidRootPart.Parent then
			connection:Disconnect()
			hitbox:Destroy()
			return
		end

		-- Update hitbox position
		local lookVector = humanoidRootPart.CFrame.LookVector
		local hitboxPosition = humanoidRootPart.Position + (lookVector * HITBOX_FORWARD_OFFSET)
		hitbox.CFrame = CFrame.new(hitboxPosition, hitboxPosition + lookVector) -- Orient toward look direction

		-- Check for characters in hitbox
		local overlapParams = OverlapParams.new()
		overlapParams.FilterType = Enum.RaycastFilterType.Exclude
		overlapParams.FilterDescendantsInstances = {character, hitbox}

		local partsInBox = workspace:GetPartBoundsInBox(hitbox.CFrame, HITBOX_SIZE, overlapParams)

		for _, part in ipairs(partsInBox) do
			local targetCharacter = part.Parent
			if targetCharacter and targetCharacter:FindFirstChild("Humanoid") then
				local targetPlayer = Players:GetPlayerFromCharacter(targetCharacter)

				-- FIXED: Check if NOT already hit by THIS hitbox (not foundCharacters)
				if targetPlayer and targetPlayer ~= abilityOwner and not hitboxHitPlayers[targetPlayer] then
					local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
					if targetHumanoid and targetHumanoid.Health > 0 then
						-- Mark as hit by THIS hitbox
						hitboxHitPlayers[targetPlayer] = true

						-- Apply damage first
						targetHumanoid.Health = math.max(0, targetHumanoid.Health - DAMAGE_PER_HIT)

						-- SPECIAL: If this is the Final hit, apply knockback and ragdoll (no movement lock needed)
						if vfxType == "Final" then
							-- Unlock movement if they were previously locked (ragdoll will handle everything)
							if abilityData.hitPlayers[targetPlayer] then
								local hitData = abilityData.hitPlayers[targetPlayer]
								if hitData.lockData then
									unlockTargetMovement(targetCharacter, hitData.lockData)
								end
							end

							-- Apply final knockback and ragdoll (uses same core as reference script)
							knockbackAndRagdoll(targetCharacter, humanoidRootPart.Position)

							-- Still apply highlight flicker
							flickerHighlightOnHit(targetCharacter)

							-- Mark as hit (but no lockData since ragdoll handles movement)
							abilityData.hitPlayers[targetPlayer] = {
								character = targetCharacter,
								humanoid = targetHumanoid,
								lockData = nil -- No movement lock, ragdoll handles it
							}

							print("Final hit! Ragdolled player:", targetPlayer.Name, "Health:", targetHumanoid.Health)
						else
							-- Normal hits: lock movement on first hit, then apply pushback
							if not abilityData.hitPlayers[targetPlayer] then
								local lockData = lockTargetMovement(targetCharacter, targetHumanoid)
								if lockData then
									abilityData.hitPlayers[targetPlayer] = {
										character = targetCharacter,
										humanoid = targetHumanoid,
										lockData = lockData
									}
								end
							end

							-- Apply normal pushback
							applyPushback(targetCharacter, humanoidRootPart)

							-- Create temporary red highlight flicker (removes itself after flicker)
							flickerHighlightOnHit(targetCharacter)

							print("Hit player:", targetPlayer.Name, "Health:", targetHumanoid.Health)
						end
					end
				end
			end
		end
	end)

	-- Clean up hitbox after duration
	task.delay(HITBOX_DURATION, function()
		connection:Disconnect()
		if hitbox and hitbox.Parent then
			hitbox:Destroy()
		end
	end)

	return hitbox, connection
end

-- CONSOLIDATED: Single event handler for all actions
slashAbilityEvent.OnServerEvent:Connect(function(player, action, character)
	if not player or not character or not character.Parent then
		return
	end

	-- Verify the character belongs to the player
	if Players:GetPlayerFromCharacter(character) ~= player then
		return
	end

	-- Handle ability start
	if action == "AbilityStart" then
		activeAbilities[player] = {
			character = character,
			startTime = tick(),
			hitPlayers = {}
		}
		return
	end

	-- Handle ability end
	if action == "AbilityEnd" then
		local abilityData = activeAbilities[player]
		if abilityData then
			-- Unlock all hit players (but don't disable ragdoll - let it finish naturally)
			for targetPlayer, data in pairs(abilityData.hitPlayers) do
				-- Only unlock movement if not ragdolled (ragdoll handles its own recovery)
				if not ragdolledCharacters[data.character] then
					unlockTargetMovement(data.character, data.lockData)
				end
			end

			-- Clean up
			activeAbilities[player] = nil
		end
		return
	end

	-- Handle VFX events (Stab, Slash1, Slash3, Slash4, Final)
	-- Create hitbox for this VFX (pass vfxType for special Final hit handling)
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if humanoidRootPart then
		createHitbox(player, character, humanoidRootPart, action)
		print("Created hitbox for:", action, "Player:", player.Name)
	else
		warn("HumanoidRootPart not found for", player.Name)
	end

	-- Replicate to ALL OTHER clients (exclude the original player)
	for _, otherPlayer in ipairs(Players:GetPlayers()) do
		if otherPlayer ~= player then
			slashAbilityEvent:FireClient(otherPlayer, action, character)
		end
	end
end)

-- Clean up when player leaves
Players.PlayerRemoving:Connect(function(player)
	if activeAbilities[player] then
		local abilityData = activeAbilities[player]

		-- Unlock all hit players (but don't disable ragdoll - let it finish naturally)
		for targetPlayer, data in pairs(abilityData.hitPlayers) do
			-- Only unlock movement if not ragdolled (ragdoll handles its own recovery)
			if not ragdolledCharacters[data.character] then
				unlockTargetMovement(data.character, data.lockData)
			end
		end

		activeAbilities[player] = nil
	end
end)

-- Clean up ragdolled characters when they leave
Players.PlayerRemoving:Connect(function(player)
	local character = player.Character
	if character and ragdolledCharacters[character] then
		disableRagdoll(character)
	end
end)

-- Clean up ragdolled characters when character is removed
for _, player in ipairs(Players:GetPlayers()) do
	if player.Character then
		player.CharacterRemoving:Connect(function(character)
			if ragdolledCharacters[character] then
				disableRagdoll(character)
			end
		end)
	end
end

Players.PlayerAdded:Connect(function(player)
	player.CharacterRemoving:Connect(function(character)
		if ragdolledCharacters[character] then
			disableRagdoll(character)
		end
	end)
end)
